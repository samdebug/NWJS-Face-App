/**
 * UDP 广播
 */

var dgram = require('dgram'); // UDP Socket包
var Netmask = require('netmask').Netmask; // 计算广播地址包
var _system = new(require('system').SystemInfo)(); // 获取IP与子网掩码包

var _bcst_addr = function(ifaces) {
  for (var i = 0; i < ifaces.length; i += 1) {
    var block = new Netmask(ifaces[i].address, ifaces[i].netmask);
    ifaces[i].broadcast = block.broadcast;
  }
  return ifaces;
};

var Client = function(port) {
  this.port = port;
  this.ifaces = _bcst_addr(_system.getNetList());
  this.socket = dgram.createSocket('udp4');
  this.isBound = false;
};

Client.prototype.setOnMessageListener = function(listener) {
  var self = this;
  self.socket.on('message', function(msg, rinfo) {
    for (var i = 0; i < self.ifaces.length; i += 1) {
      if (rinfo.address === self.ifaces[i].address)
        return;
    }
    listener(msg, rinfo);
  });
};

Client.prototype.sendBroadcast = function(message, listener) {
  var self = this;
  var loopFunc = function(message, broadcast, port, func) {
    func(message, broadcast, port);
  };
  if (self.isBound) {
    for (var i = 0; i < self.ifaces.length; i += 1) {
      self.socket.send(message, 0, message.length,
        self.port, self.ifaces[i].broadcast,
        loopFunc(message, self.ifaces[i].broadcast,
          self.port, listener));
    }
  } else {
    throw new Error("Socket has not bound");
  }
};

Client.prototype.start = function(listener) {
  var self = this;
  self.socket.bind(self.port, '', function() {
    self.socket.setBroadcast(true);
    self.socket.setTTL(4);
    self.isBound = true;
    listener();
  });
};

Client.prototype.close = function() {
  this.socket.close();
};

var BCST_FACTORY = function() {
  var port = arguments[0] || 2333;
  var request_json = {
    'request_type': 'bcst_request'
  };
  var detect_machines = [];
  var total_machines = [];
  
  var client = new Client(port);
  var getDetachMachines = function() {
    var regex = /^(\d{1,3}\.){3}\d{1,3}/;
    for (var i = 0; i < detect_machines.length; i += 1) {
      for (var j = 0, machine = detect_machines[i]; j < machine.length; j += 1) {
        machine[j] = machine[j].match(regex)[0];
      }
    }

    return detect_machines;
  };

  var getMachines = function() {
  	return total_machines
  }

  var broadcast = function(msec, promise) {
    var cb = function() {
      if (promise) {
        if (detect_machines.length === 0) {
          var err = {
            'status': 400,
            'responseText': '{"description": "局域网内没发现任何存储设备"}'
          };
          promise.reject(err);
        } else {
          promise.resolve();
        }
      }

      client.close();
    };

    client.setOnMessageListener(function(msg, rinfo) {
      var str = rinfo.address + ' : ' + msg;
      console.log(str);
      jsonMsg = JSON.parse(msg);
      if (jsonMsg.code === 0) {
        detect_machines.push(jsonMsg.ifaces);
        total_machines.push(jsonMsg);
      }
    });
    client.start(function() {
      console.log("Bind Successed");
      var message = new Buffer(JSON.stringify(request_json));
      client.sendBroadcast(message, function(msg, addr) {
        var str = 'send: ' + msg + ' : ' + addr;
        console.log(str);
      });
      setTimeout(cb, msec);
    });

    return promise;
  };

  var isContained = function(ip) {
    var local_ip = _system.getNetList();
    var blocks = [];
    for (var i = 0; i < local_ip.length; i += 1) {
      blocks.push(new Netmask(local_ip[i].address, local_ip[i].netmask));
    }
    for (i = 0; i < blocks.length; i += 1) {
      if (blocks[i].contains(ip)) {
        return true;
      }
    }
    return false;
  };

  return {
    'broadcast': broadcast,
    'getDetachMachines': getDetachMachines,
    'getMachines': getMachines,
    'isContained': isContained
  };
};

exports.Client = Client;
exports.BCST_FACTORY = BCST_FACTORY;